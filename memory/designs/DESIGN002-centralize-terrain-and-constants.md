# [DESIGN002] Centralize Terrain & Shared Constants

**Status:** Proposed
**Added:** 2025-12-29
**Updated:** 2025-12-29

## Summary

Centralize terrain generation and shared runtime constants so that the visual world, physics/collision, and gameplay systems share a single, deterministic source of truth for height, color, and value. This eliminates duplicated math (and mismatches like different water levels or height quantization) and makes the core sim logic testable and easier to evolve (e.g., run sim in a worker, or change quantization without accidental regressions).

## Background / Problem Statement

Current repo observations:

- `src/components/World.tsx` computes voxel heights and values using `noise2D` and ad-hoc transforms (e.g., `Math.floor((rawNoise + 0.6) * 4)`).
- `src/components/Player.tsx` independently computes a collision height using `noise2D` with a different bias (e.g., `(rawNoise + 0.1) * 4`). This creates a fragile mismatch where a player can sink into or clip through terrain if one implementation is changed.
- Water height is effectively duplicated: `World.tsx` places a water plane at `y=0.2` while `Player.tsx` uses `WATER_LEVEL = 0.1` for water physics.
- Instanced mesh matrix/color update code is repeated across `World.tsx` and `Drones.tsx` (particles), increasing risk of mistakes (missing `instanceMatrix.needsUpdate`, forgotten color update branch), and producing duplicate code.

This design centralizes terrain logic and constants, and introduces a small set of carefully defined helpers with clear tests and migration steps.

## Goals

- Single deterministic terrain API used by both rendering and physics.
- Shared constants for water level, world radius, seeds, player physics constants, etc.
- Small, well-typed TS modules that are straightforward to unit test.
- No visible gameplay regression after migration; existing user-facing behavior must remain intact.

## Requirements (EARS-style)

- WHEN the World component generates terrain, THE SYSTEM SHALL use `computeVoxel(x,z,seed)` that returns voxel metadata (y, color, value, type) [Acceptance: `tests/terrain.test.ts` compares a sample grid generated by World and `computeVoxel` to ensure consistency].

- WHEN the Player calculates ground collision, THE SYSTEM SHALL use `getSurfaceHeight(x,z,seed)` so collision equals visible surface [Acceptance: integration test(s) ensure the player's ground height equals the nearest generated voxel height at matching coordinates].

- WHEN code needs global tuning constants (water, gravity, speed), THE SYSTEM SHALL import them from `src/constants.ts` [Acceptance: no hard-coded constants remain in `Player.tsx` or `World.tsx`].

- WHEN instanced mesh transforms/colors are modified, THE SYSTEM SHALL use `src/render/instanced.ts` helpers to set matrix & color and mark `needsUpdate` correctly [Acceptance: no repeated/manual `needsUpdate` patterns remain; tests verify helpers set flags].

## Proposed Modules & Public API

### src/constants.ts

Exports plain constants for reuse across the codebase:

- `BASE_SEED: number` (e.g., 123)
- `PRESTIGE_SEED_DELTA: number` (e.g., 99)
- `WORLD_RADIUS: number` (replica of current constant)
- `WATER_LEVEL: number` (single source of truth for water plane / swim physics)
- `PLAYER_HEIGHT, WALKING_SPEED, RUNNING_SPEED, JUMP_FORCE, GRAVITY` (player physics)

Usage: `import { WATER_LEVEL } from '@/constants';`

### src/sim/terrain.ts

Pure functions that encapsulate terrain logic (no side effects):

- type Voxel = { id:number; x:number; y:number; z:number; color: Color; value:number; type: 'water'|'solid' }
- `getSeed(prestigeLevel: number): number`
- `computeVoxel(x: number, z: number, seed?: number): Voxel`
- `getSurfaceHeight(x: number, z:number, seed?: number): number` (returns quantized height used by world grid)
- `getSmoothHeight(x:number,z:number,seed?:number): number`

Implementation detail: These functions may (initially) call through to `noise2D` from `src/utils.ts` but will be the canonical place for quantization bias and thresholds.

### src/render/instanced.ts

Small helper functions for setting instance transforms & colors safely and efficiently:

- `setInstanceTransform(mesh: InstancedMesh, index: number, opts: { position?: Vector3; scale?: Vector3; rotation?: Euler | Vector3 })` — sets the matrix using a reusable `Object3D` internally.
- `setInstanceColor(mesh: InstancedMesh, index: number, color: Color)`
- `applyInstanceUpdates(mesh: InstancedMesh, opts?: { matrix?: boolean; color?: boolean })`

These helpers avoid repeated instantiations of `Object3D` inside hot code and centralize `needsUpdate` logic.

### src/sim/economy.ts (optional)

- `getUpgradeCost(params)` — extracts cost math from store to a pure function (facilitates unit testing of economic rules).

## Data Flow

1. UI or game startup sets `prestigeLevel` in the store.
2. `getSeed(prestigeLevel)` is used when generating the world: `World` will call `computeVoxel(x,z,seed)` for every grid position to produce deterministic voxels.
3. `World` uses `render/instanced.ts` helpers to set matrices and colors for instanced meshes.
4. Player collision checks `getSurfaceHeight(x,z,seed)` on its movement loop (use with cached or minimal calls to reduce cost).
5. Drone logic continues to request targets via the `World` imperative API, which is unchanged; however the underlying world generation is now driven by the central `computeVoxel`.

## Migration Strategy

- Implement new modules and tests in isolation (`src/constants.ts`, `src/sim/terrain.ts`, `src/render/instanced.ts`).
- Add tests that assert the new module's outputs match current behavior for a handful of sample coordinates.
- Replace `World.tsx` generation to call `computeVoxel` (keep the same public surface and visuals).
- Replace `Player.tsx` height calculation to call `getSurfaceHeight` and remove duplicate math. Run integration tests.
- Replace instanced update blocks with helpers; verify visuals remain identical and tests pass.
- Keep backward-compatible stubs in `src/utils.ts` that delegate to the new functions and mark them as deprecated (add a TODO to remove after full migration).

## Testing & Validation

Unit tests:
- `tests/terrain.test.ts` — Determinism and range checks for `computeVoxel` and `getSurfaceHeight`.
- `tests/economy.test.ts` — (if economy helper extracted) cost math tests.

Integration tests:
- `tests/world-player-integration.test.ts` — Spawn small world, sample a few coordinates, assert that `getSurfaceHeight` equals the visible voxel height at same coordinates, and assert player does not sink.

Manual verification:
- Run `npm run dev`, test walking across terrain and crossing water, confirm no visual/pop-through errors.

## Acceptance Criteria

- All unit tests added pass.
- Player-ground collisions reflect the visible world generically across sample coordinates.
- No remaining ad-hoc `noise2D`/bias math is duplicated between `World` and `Player`.
- `WATER_LEVEL` is used both by `World.tsx` water plane and `Player.tsx` physics.
- PR includes a short exec summary and tests.

## Performance Considerations

- Keep `computeVoxel` allocation-free where possible; return plain objects or reuse internal small caches.
- Avoid calling `computeVoxel` on every frame across wide areas — Player should sample local positions only.
- Instanced helper should reuse a single `Object3D` to avoid allocations inside `useLayoutEffect` and `useFrame`.

## Risks & Mitigations

- Small visual differences due to quantization changes: mitigate with sample-based comparison tests and, if necessary, add a compatibility mode or adjust bias constants.
- Mistakes during swap can introduce regressions: mitigate by adding unit tests that lock outputs for a sample set of coordinates and quick integration checks.

## Estimated Effort & Confidence

- Estimated effort: 3-6 hours (constants + terrain module + tests + World/Player changes + small refactors). Lower if only the core pieces are touched.
- Confidence: High (≥ 85%).

---

**Next steps:** Implement `src/constants.ts` and `src/sim/terrain.ts`, add unit tests for terrain determinism, then update `World.tsx` and `Player.tsx` to use the new APIs.

## Implementation Status

- Implemented: `src/constants.ts`, `src/sim/terrain.ts` (with `computeVoxel`, `getSurfaceHeight`, `getSmoothHeight`, `getSeed`, `generateInstances`), `src/sim/player.ts`, and `src/render/instanced.ts` helpers.
- Migrated: `src/components/World.tsx` to use `generateInstances` and `populateInstancedMesh`, `src/components/Player.tsx` to use `getPlayerGroundHeight` and shared constants, and particle updates to use instanced helpers.
- Tests: Added/updated tests under `tests/` covering constants, terrain, voxels, instanced helpers, world generation, and player physics.
- Validation: Ran lint/typecheck/tests and built a production bundle (no build errors; bundle size warning noted).

## Follow-up

- Prepare a focused PR that includes the design doc, all tests, and a concise migration summary (files changed, tests added, and acceptance checklist).  
- Create a follow-up design (`memory/designs/DESIGN003`) and tasks for splitting drone simulation out of `Drones.tsx` into a `DroneManager`/`src/sim/drones.ts` so rendering and simulation are fully separated and the sim can be run in a worker if needed.

